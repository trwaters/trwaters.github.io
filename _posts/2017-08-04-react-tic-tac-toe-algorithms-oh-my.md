---
layout: post
title: "React, Tic-Tac-Toe, and Algorithms, oh my!"
tags:
- Algorithms
- React
thumbnail_path: blog/algorithm.jpg
---

I was in a developer's meeting at my internship (Titan Web Marketing Solutions) about a week or so ago. We were talking about interactive dashboards 
and I voiced up and told everyone that I have seen it done with React. The catch-  I could barely understand how it was built. I keep hearing about React and have seen projects built with it, but it was still very foreign to me. A Developer was reading up on the docs for React after the meeting and found a walk-through tutorial for a very simple tic-tac-toe game. It wasn't pretty, but the whole point was to at least grasp a little bit of React. 

Here is a link to the tutorial: [https://facebook.github.io/react/tutorial/tutorial.html](https://facebook.github.io/react/tutorial/tutorial.html) 

So I took a shot at it over the weekend and got it running on localhost thanks to node.js and React's boilerplate (react-create-app). My first real React app! 

When I saw it running with the React Inspector add on for Chrome lit up (indicating that it was a React app), it sure was satisfying. 

It was missing something, though. Well, three things.

1.  You couldn't clear the board after the game is over,
2.  You couldn't choose what player you wanted to play as,
3.  You were playing against yourself (no computer intervention). Not that fun.

Did I get it to do what I wanted to? Yes, but not after a couple of struggles. See the app in action here: [https://robertspurlin.github.io/tic-tac-toe](https://robertspurlin.github.io/tic-tac-toe) 
_Hold on there, man. I'm not even sure why you would do this in React. Why not just good ol' Javascript?_ 
There is nothing wrong with vanilla javascript, and in fact, that's how I would of built the app initially if it weren't for this tutorial. 
B
ut I wanted to push myself. I wanted to understand why React was so popular. 

The tutorial (above) provides you two choices: to code in your browser in an environment like Codepen, or to do it locally. I chose locally, and the tutorial even has a little bit of a walkthrough for doing that as well. I did it exactly like the tutorial recommended and it worked like a charm. 
Here's how I got it started: Downloaded the newest version of node.js - can be found on their website.  
Don't know if you have node installed already? Open up Terminal/iTerm and run `node -v` 

Went into the directory that I wanted the app the be in (in Terminal/iTerm) and ran `npm install -g create-react-app` (this installs that boilerplate that I was talking about. If it doesn't work on first try like it didn't with me, try running it again with `sudo` in front of it. It will ask for your administrative password of your computer. 

After it was done, I called create-react-app with whatever I wanted the name of the project to be (I chose tic-tac-toe) - `create-react-app tic-tac-toe` 

It creates the tic-tac-toe directory for you after it is finished with the files to start out. When it's done, I went into the new directory that create-react-app made so nicely for me (`cd tic-tac-toe`) 

Finally, I ran `npm start`. When that was finished, my browser opened with localhost:3000 as the URL, and a starter page popped up. It's alive! Here is the code for the whole project. 

It'll probably be easier if you [follow along.](https://github.com/robertspurlin/tic-tac-toe/blob/master/src/index.js) The instructions for making this game are found in the tutorial and are well-written. 

If you have finished it and want to follow along, great! If you still want to follow along but haven't built the app, I suggest you start there. If you follow the tutorial that React gives you, you will end up with something like [this](https://codepen.io/gaearon/pen/gWWZgR?editors=0010). 

I stopped at where the game was fully functional and deleted all the history code. It was fine and all, but I just wanted the game. Let's get cracking on those problems that I had with the game. 

Problem 1- you couldn't clear the board after the game was over. You just need like a button or something that appears after the game is over. 

So I added another div element with only the variable `{button}` in board's return call in it's render function (right below the status). I figured that the variable would be empty until the game is over, right? There is an if test that tests for the winner right above the return() call that changes `status` when the game is over. So, let's initialize `button` with `status`. And when the game is over, set button to a JSX element (that isn't defined yet) that calls this.resetClick() (also not defined). So let's define button that accepts onClick. I just put it on top of the file, where `Square` is defined. onClick is coming from the parent of Button via props, and Button is being called with this.resetClick(). **Important:** this.resetClick() needs to be in Board. Why? Because resetClick() changes the state of the Board with setState. You can't do that outside of Board. I set the squares to just an empty array. It'll work with the rest of the components. So let's recap. the variable button appears with a JSX element when the game is over. That JSX element has an onClick call to a function that changes the state of the board (clearing the board).

Next! 

2\. You couldn't choose what player you want to be. 

Let's take a look at Game (not Board). It just renders Board, right? What if we changed it to render another variable? What I did was that I added a contructor function in Game that will initialize the state (because Game is a React.Component, it is able to do so). Let's say that hasChosen (a name that I made up) is set to false on initialization of Game. Makes sense. We also need to create another state in this function that will tell Board who is who. I created another state named isX, and it honestly doesn't matter what we set to (true or false, or even null). Just as long as it is able to tell Board who is who at the end of the day. I set mine to true just because. In the render function of Game, lets create a variable (I named mine board) that changes based on what hasChosen is. I made two buttons that both have another onClick function that will change the state of Game when called. In render, I am testing on whether hasChosen is true or false. It hasChosen is false, the variable is set to call Question(), which returns the two buttons with the question "X or O?". Both buttons have an onClick argument that calls a function which takes a boolean as an argument and are appropriately filled with "X" and "O". If hasChosen is true, the variable is set to render Board. Let's think about this. We have two buttons now that calls another function (for those following along, it's test(bool)). We want that function to change the state of the board. But what will tell the board who is who? Enter isX. I have the onClick function to accept a boolean. If that boolean is true (therefore meaning that isX is true), it sets the state to hasChosen:true (rendering the board) and isX:true (which will tell the board that the human is X and the computer is O). Likewise, if that boolean is false, it sets the state to hasChosen:true (still rendering the board), but with isX: false. Great. Now the last thing to do is tell Board who is who. Let's set up Board to take props (just have to change constructor() and super() to constructor(props) and super(props)). If we look at the constructor, it has xIsNext, which tells the board what player will go first (it is set to true). Change it to props.isX, so it will take the decision from Game and set it to Board. You should be able to choose what player you want to play now. 

Next! 

3\. You were playing against yourself (no computer intervention). Not that fun. 

This is the hardest one. I implemented the first two fixes in about two hours, and was stumped at this one. How would I be able to do this? Where there is a will, there is a way, right? Let me say before we start that I have a function in this game that I can call at any time that will return a copy of the board. This will become useful when the computer is considering possible moves. As a general rule, you should make copies of what you are working on so if it becomes screwed up, not a big deal at all. Let's start by defining who is who (human or computer). I put the definition in handleClick of the squares, and it decides who is who based on the state of board. (Note: not a const variable because every time you click on the squares, this.state.xIsNext has been reverted back by a function that we will cover later) `computer = this.state.xIsNext ? 'O' : 'X'; human = this.state.xIsNext ? 'X' : 'O';` Let's look at handleClick while we are here. Tests for a winner, and if not, sets the index of the Board (array), changes the board, and changes the player. If only I can call a function in that setState without breaking anything. Surprise! You can, but as a callback in setState. Example: `this.setState({squares: squares,xIsNext: !this.state.xIsNext,},this.AIDecider);` It just needs to be referenced after the curly cues end. 

_Hold on, what is AIDecider?_

 Glad you asked. Think of it as the waiter, and Board is a food blogger with a good following that is looking for any reason to tear this place up. Board wants something, and AIDecider will bring it to Board (by using setState). AIDecider doesn't do the cooking, but is still a major important part of the restaurant. For example, if one of the cooks gives it something that looks or tastes bad (maybe there is an error, or maybe the customer is allergic to something in the dish), the waiter will catch that and won't give it to the customer (unless the cooks give AIDecider something even worse at the end of the move). It wants to give the food blogger the best that the cooks can offer. Same thing with Board and AIDecider. The cooks bring back a value, and AIDecider decides which is the best one to give to Board. We will get to who does the cooking later. AIDecider has a loop in it that runs until the number of times it will run is larger than the board itself. Or, in code terms, `for (let i = 0; i < boardCopy.length; i++)` The first thing that is needed for this to work is a function that returns a board with a possible move. If the actual board itself is nothing other than an array, then we can run i through this function. What this function has to do is make sure that what AIDecider gave it is even possible. If it is, then return the board to AIDecider so it can be determined whether it is a good move or not (by the cooks). So. Let's make this function accept three arguments. The index that AIDecider is looping through at that point in time, the player in question so it knows what to put into the array if it is valid, and a copy of the board. I named this function validMove. The first thing that validMove does is take a copy of the board thanks to the handy dandy board copier function and stores it in a variable. Then, it makes sure that the index that it is given is an okay move to make. If it is, return the board. If not, return null. 

 Now that we have that under control, let's go back to AIDecider. It calls validMove and returns either a board or null. If a board is returned, then it sends the boards to one of the cooks where it will talk with the other cook in the back and make sure that it is a good move or not. This is where the MiniMax algorithm comes in. The basic premise is that it is testing for the best possible situation based on the given board. 

 It works a little bit like this: _Hey there, minScore AKA my coworker, AIDecider gave me a board and wants to know if it's good. Before I, maxScore, ask for your opinion, I want to make sure. No hard feelings, right bro?_ 

 So maxScore has three tests before it calls minScore. The first test is to make sure that the board given is a winning board. Who wins, you ask? It tests for if the computer wins if this board is played. If so, return a nice number. I'm thinking 10. The second test is testing for the opposite (if the board results in a winning board for the human). This one returns -10 if its true. The third and last one tests for if the board results in a tie. If so, return 0. Recap: Computer wins, yay! 10 points. Tie, meh. 0 points. Lose, bad. -10 points. But what if the board that maxScore gets is incomplete? What if the board doesn't result in a win, loss, or tie at all? Well, what maxScore does is that it adds a possible move on top of the move that AIDecider is considering and sends that board (with the extra move) to validMove. If validMove gives maxScore it's blessing, it needs to test again if the board will result in a win/loss/tie/what have you. 

 _Note: the computer is now thinking two moves ahead if maxScore adds on a move. _ But how can maxScore determine whether it is a good move or not? It's already tested a board once, and adds a move as a last resort (in the else argument in the if statement). That's when it calls minScore. minScore has the same exact tests that maxScore does. minScore also has a loop for adding moves itself (if it's needed, of course). If minScore cannot determine that the board is complete, that's when it adds another move for consideration. **Because minScore is thinking three moves ahead when it adds it's own move, minScore sends validBoard the computer's value instead of the human value. ** Why, you ask? If the computer can't go twice in the row, neither can the human. maxScore runs first and sends validBoard a possible move that the human could make. If it needs to predict the next move, it calls minScore (therefore thinking three moves ahead). Before we really dig deep into maxBoard and minBoard, I want to note the differences. **There are only three major differences between maxBoard and minBoard and they are absolutely crucial to making this work. We have already discussed one of the differences (what they send validBoard). ** The other differences are the most interesting and is the heart of the algorithm. Ready? If the board is incomplete, it's true that maxScore calls minScore. But here's the kicker, they will keep calling each other until one of them returns a value, whether it'd be a win situation, a tie, or a loss (represented in those nice numbers that we have them returning). So, let's imagine this conversation that maxScore and minScore are having. 

 _(maxScore) - Hey, minScore, I can't figure this one out, even after I added another move. Help me?_ _(minScore) - I don't know man, it has to be a complete board. Otherwise, I'm just going to give you another possible move on top of the move that you added. If I do, I'm just going to send the board with my move back to you. _ _(maxScore) - I don't care, just give me something. I want this over with. _ So. What happens if maxScore is given a number (representing the outcome of such move)? maxScore has an arbitrary variable that is able to be rewritten (by using let or var). It is set to positive whatever, so long as it's bigger than any value that the others would return it. I chose 100\. If the number that minScore gives maxScore is **smaller** than 100 (which it always will be the first round), it will **reassign the arbitrary variable with whatever number it is given.** This is important for the second/third round because it is testing for anything worse that minScore gave it. It returns that number no matter what it is at the end of the loops. If it can't find anything worse, so be it.

 _Hold on, what? Why would it rewrite on something smaller if it testing to win the game? I don't understand._ 

 Remember that maxScore is the only function that talks to AIDecider? maxScore is looking for every reason to knock down minScore's ideas. So, if minScore gives maxScore a 10 initially, then runs another move that scores a 0 or -10, it will go back to AIDecider at the end of everything and tell AIDecider that this move in question isn't a good one. Likewise, if minScore gives maxScore a -10 initially and then gives it a 10, it will **still** go to AIDecider and tell it that the move in question isn't good. 

 _What if maxScore returns to minScore with a value?_ 
 
 It just returns the highest value to maxScore. Chances are that minScore will only run it's loop (and call maxScore) once or twice, and maxScore doesn't remember what it gives minScore. This means that minScore's arbitrary value is rewritten if maxScore gives it a higher number. Therefore, minScore's arbitrary number would have to be smaller than anything possible. I chose -100. Based on the first test of maxScore, we can imply that maxScore doesn't like calling minScore but has to when it is necessary. Maybe it doesn't trust minScore. Or maybe maxScore knows that the food blogger can be a jerk sometimes if the restaurant doesn't give him/her the best that they can offer. It doesn't matter. If minScore returns with a value, maxScore will then test to see if minScore gave it a worse value before. If not, it will return the value that minScore gave it. If so, it will return the worse value and make it AIDecider's problem to deal with. Recap (TL;DR): maxScore is the first test, and will add on it's own move and send the modified board to minScore if it needs to. minScore is the second test, and will add on another move and send it to maxScore, and so on until there are no more possible moves. The recursion belongs in both maxScore and minScore's else arguments in their if statements. So, after that lovely conversation with maxScore and minScore, maxScore finally returns with a value. AIDecider doesn't need to know what is happening back in the kitchen, and honestly it doesn't care. It's a mess of recursion back there anyways. It has it's own loop to deal with. AIDecider's arbitrary value is set to -100 like minScore and will change on anything that is more than that value. So if -100 rewrites to 0 (based on a tie that maxScore gave it), and on the next move, maxScore gives AIDecider a 10, it will rewrite that. 

 _Side note- based on the logic of the arbitrary values, it means that the human is the **maximizing player **(meaning that this player is assumed to make the choice that will eventually lead to a win) and the computer is the **minimizing player **(meaning that this player is assumed to make a choice that will minimize the risk of a loss, even if that means blocking the other player from winning). maxScore guesses the best move that the maximizing player would (or should) make, and minScore guesses the best move that the minimizing player will make. For my game theory friends, you can read more about it by reading the Wikipedia article on the MiniMax algorithm found [here](https://en.wikipedia.org/wiki/Minimax)._ 

 AIDecider remembers the index that it was on that gave it the highest value. It wants to pick a winner! So when maxScore and minScore are done fighting back there, AIDecider can finally return to board with an index that is associated with the highest value. At the end of the day, AIDecider runs setState on the board with the new move that maxScore and minScore chose added onto it. It also changes xIsNext while it's there, turning it over to the human. And that's it, folks. Hope you enjoyed my awesome lesson on game theory, and you know now the story of why it took me so long to figure this out (because math is hard, basically). 

 Oh, and did I answer my question on why I think React is so popular? 

 Remember that we made a clear button that erases the entire array? Well, React's special sauce is that it remembers the old state of the DOM and rewrites all that is changed. Example, if I only made two moves and the computer beats me, when I hit reset, it only changes the difference between the new array and the old. Why does that matter, you ask? It speeds up reload times 10 fold. Normally, it would erase the entire array and reload the board. Think of it like the difference between a sleeping lap cat and a cheetah chasing it's pray. Sure, both are cats and the cheetah is much more muscular and complicated, but the cheetah is much more faster and much more efficient than the sleeping lap cat. Although it is hard to see with this application because we only have two real components with three dummy components, it matters greatly when you have tens/hundreds of components that talk to each other. Imagine only like 5 of those components changing based on whatever. Only the parts of those 5 components changing will change. The rest of the tens/hundreds of components will remain unaffected. A good example of an application that needs this is my Twitch list ([https://robertspurlin.github.io/TwitchTV-Project/](https://robertspurlin.github.io/TwitchTV-Project/)). Notice how when you click a user's thumbnail, the whole array of users disappears and appears without the user in question.  Now, lets imagine if I wrote this in React. If you clicked on the thumbnail, React would only remove the user in question and leave the rest unaffected. Seems like a blessing in disguise to me. All that needs to be done is to actually get ahead of the learning curve... Until next time.